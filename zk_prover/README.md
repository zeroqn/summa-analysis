# ZK Prover

This directory contains the Halo2 ZK circuit implementation for the Summa Proof of Solvency protocol.

## Usage

To build, test and print the circuits, execute

```
cargo build
cargo test --release --features dev-graph
```

## Documentation

The documentation for the circuits can be generated by running

```
cargo doc --no-deps --open
```

## Powers of Tau Trusted Setup

For testing purposes, it's not necessary to download the `ptau` file. The `generate_setup_artifacts` function can manage this by generating a new setup from a randomly generated value. This automated generation process is intended for testing and development convenience, and it should not be used in production.
For real-world situations, you must provide the path of a specific `ptau` file to the `generate_setup_artifacts`. The circuit will use the randomness from the given file. You can find an example that initializes a `Snapshot` instance [here](https://github.com/summa-dev/summa-solvency/blob/11d4fce5d18f6175804aa792fc9fc5ac27bf5c00/backend/src/apis/snapshot.rs#L115-L116) in the backend.

## Build an Inclusion Verifier Contract

A `gen_inclusion_verifier.rs` script is provided to generate a solidity contract that can be used to verify the proof of user inclusion into CEX liabilites. The script can be run as follows:

```
cargo run --release --example gen_inclusion_verifier
```

The script will generate a new `InclusionVerifier.sol` and `InclusionVerifier.yul` contracts in `contracts/src`.

Note that the generic parameters of the circuits `LEVELS`, `N_CURRENCIES` and `N_BYTES` are set to `4`, `2` and `8`. This means that the circuit is tuned to verify the proof of inclusion for an exchange with a userbase of 4 levels (2^4 = 16 users), 2 currencies and a balances in a range of 8 bytes. These parameters can be changed in the script.

The verifier are generated based on a trusted setup located at `backend/ptau/hermez-raw-11`. Note that setting different generic parameters may require a bigger trusted setup. More details on how to generate a trusted setup can be found [here](https://summa.gitbook.io/summa-book/backend/summa-solvency#3.-generate-verifier-contract).

## Build a Commitment

A `gen_commitment.rs` script is provided to generate a commitment out of a Merkle Sum Tree. In particular, the example takes a csv file located in "../csv/entry_16.csv", build a Merkle Sum Tree and extract a commitment out it. The commitment is made of the `root_hash` and the `root_balances`. 

The script will eventually generate a `commitment_solidity_calldata.json` file that contains some testing calldata to be used within `contracts` to test the publishing of the commitment to the Summa Smart Contract.

The script can be run as follows:

```
cargo run --release --example gen_commitment
```

Note that the generic parameters of the Merkle Sum Tree `N_CURRENCIES` and `N_BYTES` are set to `2` and `8`. This means that this should go in pair with a Inclusion Verifier Circuit tuned to the same generic parameters.

## Build an Inclusion Proof

A `gen_inclusion_proof.rs` script is provided to a proof of inclusion that can verified by the Smart Contract. The script can be run as follows:

```
cargo run --release --example gen_inclusion_proof
```

This generated proof is saved in `inclusion_proof_solidity_calldata.json`. The file contains some testing calldata to be used within `contracts` to test the verifier. 

In the example, the proof is generated based on the `../csv/entry_16.csv` file for a specific `user_index`, which is set to 0 by default. The setup parameters are set to `LEVELS = 4`, `N_CURRENCIES = 2` and `N_BYTES = 8`. The ptau file is located at `backend/ptau/hermez-raw-11`. Note that these parameters should go in pair with the ones used to generate Inclusion Verifier Circuit and the Commtiment in order to generate a valid proof.

## Incremental Nova Verifier 

The Incremental Nova Verifier is an experimental feature that allows a user to verify a sequence of proofs of inclusion in one shot. More details can be found in the [write up](https://hackmd.io/@summa/HkGMF4Ovn).

We provide an example to test the Nova verifier. The build folder already contains the artifacts generated by the circuit compilation. If you want to recompile the circuit, you can run the following command:

```
$ cd src/circom
$ npm install
$ circom incremental_mst_inclusion.circom  --r1cs --wasm  -o ../../examples/build --prime bn128
```

To run the Nova Incremental Verifier example run:

```
cargo run --release --example nova_incremental_verifier
```

## Benches

The benchmarking included the following areas:

- Merkle Sum Tree Generation
- Verification Key Gen for MstInclusion Circuit
- Proving Key Gen for MstInclusion Circuit
- ZK Proof Generation for MstInclusion Circuit
- ZK Proof Verification for MstInclusion Circuit

In order to run the benchmarking, we provide a set of dummy `username, balances` entries formatted in csv files. The csv files can be downloaded as follows

```bash
mkdir -p benches/csv
cd benches/csv
wget https://summa-solvency.s3.eu-central-1.amazonaws.com/1_entry_2_20.zip
unzip 1_entry_2_20.zip
```

The file naming convention, such as `1_entry_2_20.csv`, follows the pattern `[number of cryptocurrency]_entry_2_[power of 2]`. In this example, `1_entry` indicates a single currency, and the `2_20` part represents $2^{20}$ entries in the file. These entries, which are intended to populate the Merkle sum tree and feed the zk prover, correspond to the number of users on the exchange.

To run the benches

`cargo bench`

You can set the following parameters to run the benches:

- `LEVELS` -> the number of entries in the merkle sum tree. By default it is set to 20, which means that the benches will run for 2^20 entries.
- `SAMPLE_SIZE` -> the number of samples to run for each bench. By default it is set to 10, which is the minimum allowed by criterion.rs
- `N_CURRENCIES` -> the number of currencies to be used in the benchmarking. By default it is set to 1.

Note that the `k` of the circuit may vary based on the LEVELS

Furthermore the benchmarking function `verify_zk_proof_benchmark` will also print out the proof size in bytes.

## Current Benches

Benchmark results are available at [Summa Gitbook](https://summa.gitbook.io/summa-book/backend/summa-solvency/benchmarks)
